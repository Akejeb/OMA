# Biclustering

```{r setup, echo=FALSE, results="asis"}
library(rebook)
chapterPreamble()
```

Biclustering is a clustering method, which simultaneously clusters rows and columns.
The idea is to find clusters where subset of features/samples share similar pattern 
over samples/features. 

There are multiple biclustering packages available, In this example, we use following methods
-   [biclust](https://cran.r-project.org/web/packages/biclust/index.html)
-   [cobiclust](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.13582)

_cobiclust_ is especially developed for microbiome data whereas _biclust_ is more
general method. In this section, we show three different cases and example 
solutions to apply biclustering to them. 

1.   Taxa vs samples
2.   Taxa vs biomolecule/biomarker...
3.   Taxa vs taxa

Biclusters can be visualized using hetamap or boxplot, for instance. 
Check more ideas for heatmaps from 
[here](https://microbiome.github.io/OMA/microbiome-community.html#composition-heatmap).

## Taxa vs samples

When you have microbial abundance matrices, we suggest to use _cobiclust_ which is
designed for microbial data. 

Load example data
```{r load-pkg-data}
library(mia)
# if(!require(microbiomeDataSets)){
#     BiocManager::install("microbiomeDataSets")
#     library(microbiomeDataSets)
# }
# 
# mae <- HintikkaXOData()
# 
# mae

data("GlobalPatterns", package = "mia")

tse <- GlobalPatterns

tse 
```

Only the most prevalent taxa are included in analysis to make analysis quicker. 

```{r cobiclust_1}
# Subset data so that rarest taxa a´re filtered out
tse <- subsetByPrevalentTaxa(tse, rank = "Phylum", prevalence = 0.1, detection = 0.001)

tse
```

_cobiclust_ takes counts table as an input and gives _cobiclust_ object as an output.
It includes clusters for taxa and samples. 

```{r cobiclust_2}
if(!require(cobiclust)){
    install.packages("cobiclust")
    library(cobiclust)
}

# Do clustering; use counts table´
clusters <- cobiclust(assay(tse, "counts"))

# Get clusters
row_clusters <- clusters$classification$rowclass
col_clusters <- clusters$classification$colclass

# Add clusters to rowdata and coldata
rowData(tse)$clusters <- factor(row_clusters)
colData(tse)$clusters <- factor(col_clusters)

# Order data based on clusters
tse <- tse[order(rowData(tse)$clusters), order(colData(tse)$clusters)]

# Print clusters
clusters$classification
```

Next we can plot clusters. Commonly used plot is heatmap with annotations. 

```{r cobiclust_3}
# clr-transform
tse <- transformSamples(tse, method = "clr", pseudocount = 1)

# Creates annotations. Levels should be same if column names are the same. 
# Here samples include 3 clusters, and taxa 2. That is why we have to make 
# name unique. 
annotation_col <- data.frame(colData(tse)[, "clusters", drop = F])
colnames(annotation_col) <- "col_clusters"

annotation_row <- data.frame(rowData(tse)[, "clusters", drop = F])
colnames(annotation_row) <- "row_clusters"

# Create a heatmap
pheatmap(assay(tse, "clr"), cluster_rows = F, cluster_cols = F, 
         annotation_col = annotation_col,
         annotation_row = annotation_row)

```

Other common plot is boxplot, where clusters are plotted separately. 

```{r cobiclust_4}
if(!require(ggplot2)){
    install.packages("ggplot2")
    library(ggplot2)
}
if(!require(gridExtra)){
    install.packages("gridExtra")
    library(gridExtra)
}

# ggplot requries data in melted format
melt_assay <- meltAssay(tse, abund_values = "clr", add_col_data = T, add_row_data = T)

# Use grid.arrange to arrange two plots side-by-side
grid.arrange(
  
ggplot(melt_assay) + geom_boxplot(aes(x = clusters.x, y = clr)) + labs(x = "Taxa clusters"),
ggplot(melt_assay) + geom_boxplot(aes(x = clusters.y, y = clr)) + labs(x = "Sample clusters"),

nrow = 1)
```

## Taxa vs biomarker

Here, we analyze cross-correlation between taxa and biomarkers. This is a case, where
we use _biclust_ method which is suitable for numeric matrices in general.


Load data

```{r biclust_1}
if(!require(microbiomeDataSets)){
    BiocManager::install("microbiomeDataSets")
    library(microbiomeDataSets)
}

mae <- HintikkaXOData()

mae
```

We analyze correlation between taxa and biomarkers. First, rarest taxa are filtered out.
Then cross-correlation matrix is calculated. 

```{r biclust_2}
# Subser data
mae[[1]] <- subsetByPrevalentTaxa(mae[[1]], rank = "Genus", prevalence = 0.2, detection = 0.001)
# clr-transform
mae[[1]] <- transformSamples(mae[[1]], method = "clr", pseudocount = 1)

############################ REMOVE THIS WHEN BUG IN GETEXPERIMENTCROSSCORR IS FIXED
rownames(mae[[1]]) <- make.unique(rownames(mae[[1]]))

# Calculate correlations
corr <- getExperimentCrossCorrelation(mae, 1, 3, abund_values1 = "clr", abund_values2 = "signals", mode = "matrix")
head(corr)
```

_biclust_ takes correlation matrix as an input and returns _biclust object. 

```{r biclust_3}
# Load package
if(!require(biclust)){
    install.packages("biclust")
    library(biclust)
}

# Find biclusters
bc <- biclust(corr, method=BCPlaid(), fit.model = y ~ m,
              background = TRUE, shuffle = 100, back.fit = 0, max.layers = 10,
              iter.startup = 10, iter.layer = 100, verbose = FALSE)

bc
```

The object includes cluster information. However compared to _cobiclust_, 
_biclust_ object includes only information about found clusters, not general cluster.

Meaning that if one cluster size of 5 features was found out of 20 features, 
those 15 features do not include to any cluster. That is why we have to create an
additional cluster for features/samples that are not assigned into any cluster.

```{r biclust_4}
# Get cluster info for features and convert it into data frame
bicluster_features <- bc@RowxNumber
bicluster_features <- data.frame(bicluster_features)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those features that are not included in clusters that were found.
if( nrow(bicluster_features) != nrow(corr) ){
    bicluster_features <- data.frame(cluster = rep(TRUE, nrow(corr)))
} else {
  # Create additional cluster that includes those features that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_features) > 0, FALSE, TRUE)
  # If additional cluster contains features, then add it
  if ( any(vec) ){
    bicluster_features <- cbind(bicluster_features, vec)
  }
}

# Give row and column names
rownames(bicluster_features) <- rownames(corr)
colnames(bicluster_features) <- paste0("cluster_", 1:ncol(bicluster_features))

head(bicluster_features)
```

```{r biclust_5}
# Get cluster information for samples
bicluster_samples <- t(bc@NumberxCol)
bicluster_samples <- data.frame(bicluster_samples)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those samples that are not included in clusters that were found.
if( nrow(bicluster_samples) != ncol(corr) ){
    bicluster_samples <- data.frame(cluster = rep(TRUE, ncol(corr)))
} else {
  # Create additional cluster that includes those samples that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_samples) > 0, FALSE, TRUE)
  # If additional cluster contains samples, then add it
  if ( any(vec) ){
    bicluster_samples <- cbind(bicluster_samples, vec)
  }

}

# Give row and column names
rownames(bicluster_samples) <- colnames(corr)
colnames(bicluster_samples) <- paste0("cluster_", 1:ncol(bicluster_samples))

head(bicluster_samples)
```

_pheatmap_ do not allow boolean values, so they must be converted into factors.

```{r biclust_6}
bicluster_samples <- data.frame(apply(bicluster_samples, 2, as.factor))
bicluster_features <- data.frame(apply(bicluster_features, 2, as.factor))
```

Again, we can plot clusters with heatmap.

```{r biclust_7, fig.width=10, fig.height=8}
# Adjust colors for all clusters
if( ncol(bicluster_features) > ncol(bicluster_samples) ){
  cluster_names <- colnames(bicluster_features)
} else {
  cluster_names <- colnames(bicluster_samples)
}
annotation_colors <- list()
for(name in cluster_names){
  annotation_colors[[name]] <- c("TRUE" = "red", "FALSE" = "white")
}

# Create a heatmap
pheatmap(corr, cluster_cols = F, cluster_rows = F,
         annotation_col = bicluster_samples, 
         annotation_row = bicluster_features,
         annotation_colors = annotation_colors)
```

# Taxa vs taxa

Third and final example deals with situation where we want to analyze correlation
between taxa. _biclust_ is suitable for this. 

```{r biclust_8}
# Calculate cross-correlation
corr <- getExperimentCrossCorrelation(mae, 1, 1, abund_values1 = "clr", abund_values2 = "clr", mode = "matrix")

# Find biclusters
bc <- biclust(corr, method=BCPlaid(), fit.model = y ~ m,
              background = TRUE, shuffle = 100, back.fit = 0, max.layers = 10,
              iter.startup = 10, iter.layer = 100, verbose = FALSE)
bc
```

```{r biclust_9}
# Get cluster info for features and convert it into data frame
bicluster_features <- bc@RowxNumber
bicluster_features <- data.frame(bicluster_features)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those features that are not included in clusters that were found.
if( nrow(bicluster_features) != nrow(corr) ){
    bicluster_features <- data.frame(cluster = rep(TRUE, nrow(corr)))
} else {
  # Create additional cluster that includes those features that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_features) > 0, FALSE, TRUE)
  # If additional cluster contains features, then add it
  if ( any(vec) ){
    bicluster_features <- cbind(bicluster_features, vec)
  }
}

# Give row and column names
rownames(bicluster_features) <- rownames(corr)
colnames(bicluster_features) <- paste0("cluster_", 1:ncol(bicluster_features))

head(bicluster_features)
```


```{r biclust_10}
# Get cluster information for samples
bicluster_samples <- t(bc@NumberxCol)
bicluster_samples <- data.frame(bicluster_samples)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those samples that are not included in clusters that were found.
if( nrow(bicluster_samples) != ncol(corr) ){
    bicluster_samples <- data.frame(cluster = rep(TRUE, ncol(corr)))
} else {
  # Create additional cluster that includes those samples that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_samples) > 0, FALSE, TRUE)
  # If additional cluster contains samples, then add it
  if ( any(vec) ){
    bicluster_samples <- cbind(bicluster_samples, vec)
  }

}

# Give row and column names
rownames(bicluster_samples) <- colnames(corr)
colnames(bicluster_samples) <- paste0("cluster_", 1:ncol(bicluster_samples))

head(bicluster_samples)
```

```{r biclust_11, fig.width=14, fig.height=12}
# Convert boolean values into factor
bicluster_samples <- data.frame(apply(bicluster_samples, 2, as.factor))
bicluster_features <- data.frame(apply(bicluster_features, 2, as.factor))

# Adjust colors for all clusters
if( ncol(bicluster_features) > ncol(bicluster_samples) ){
  cluster_names <- colnames(bicluster_features)
} else {
  cluster_names <- colnames(bicluster_samples)
}
annotation_colors <- list()
for(name in cluster_names){
  annotation_colors[[name]] <- c("TRUE" = "red", "FALSE" = "white")
}

pheatmap(corr, cluster_cols = F, cluster_rows = F,
         annotation_col = bicluster_samples, 
         annotation_row = bicluster_features,
         annotation_colors = annotation_colors)
```

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
