# Biclustering

```{r setup, echo=FALSE, results="asis"}
library(rebook)
chapterPreamble()
```

Biclustering is a clustering method, which simultaneously clusters rows and columns.
The idea is to find clusters where subset of features/samples share similar pattern 
over samples/features. 

There are multiple biclustering packages available, In this example, we use following methods
-   [biclust](https://cran.r-project.org/web/packages/biclust/index.html)
-   [cobiclust](https://besjournals.onlinelibrary.wiley.com/doi/abs/10.1111/2041-210X.13582)

_cobiclust_ is especially developed for microbiome data whereas _biclust_ is more
general method. In this section, we show three different cases and example 
solutions to apply biclustering to them. 

1.   Taxa vs samples
2.   Taxa vs biomolecule/biomarker...
3.   Taxa vs taxa

Biclusters can be visualized using hetamap or boxplot, for instance. 
Check more ideas for heatmaps from 
[here](https://microbiome.github.io/OMA/microbiome-community.html#composition-heatmap).

## Taxa vs samples

When you have microbial abundance matrices, we suggest to use _cobiclust_ which is
designed for microbial data. 

Load example data
```{r load-pkg-data}
library(mia)
# if(!require(microbiomeDataSets)){
#     BiocManager::install("microbiomeDataSets")
#     library(microbiomeDataSets)
# }
# 
# mae <- HintikkaXOData()
# 
# mae

data("GlobalPatterns", package = "mia")

tse <- GlobalPatterns

tse 
```

Only the most prevalent taxa are included in analysis to make analysis quicker. 

```{r cobiclust_1}
# Subset data so that rarest taxa a´re filtered out
tse <- subsetByPrevalentTaxa(tse, rank = "Phylum", prevalence = 0.1, detection = 0.001)

tse
```

_cobiclust_ takes counts table as an input and gives _cobiclust_ object as an output.
It includes clusters for taxa and samples. 

```{r cobiclust_2}
if(!require(cobiclust)){
    install.packages("cobiclust")
    library(cobiclust)
}

# Do clustering; use counts table´
clusters <- cobiclust(assay(tse, "counts"))

# Get clusters
row_clusters <- clusters$classification$rowclass
col_clusters <- clusters$classification$colclass

# Add clusters to rowdata and coldata
rowData(tse)$clusters <- factor(row_clusters)
colData(tse)$clusters <- factor(col_clusters)

# Order data based on clusters
tse <- tse[order(rowData(tse)$clusters), order(colData(tse)$clusters)]

# Print clusters
clusters$classification
```

Next we can plot clusters. Commonly used plot is heatmap with annotations. 

```{r cobiclust_3}
# clr-transform
tse <- transformSamples(tse, method = "clr", pseudocount = 1)
# z-transgorm for heatmap
tse <- transformFeatures(tse, abund_values = "clr", method = "z", name = "clr_z")

# Creates annotations. Levels should be same if column names are the same. 
# Here samples include 3 clusters, and taxa 2. That is why we have to make 
# name unique. 
annotation_col <- data.frame(colData(tse)[, "clusters", drop = F])
colnames(annotation_col) <- "col_clusters"

annotation_row <- data.frame(rowData(tse)[, "clusters", drop = F])
colnames(annotation_row) <- "row_clusters"

# Create a heatmap
pheatmap(assay(tse, "clr_z"), cluster_rows = F, cluster_cols = F, 
         annotation_col = annotation_col,
         annotation_row = annotation_row)

```

Other common plot is boxplot, where clusters are plotted separately. 

```{r cobiclust_4}
if(!require(ggplot2)){
    install.packages("ggplot2")
    library(ggplot2)
}
if(!require(gridExtra)){
    install.packages("gridExtra")
    library(gridExtra)
}

# ggplot requries data in melted format
melt_assay <- meltAssay(tse, abund_values = "clr", add_col_data = T, add_row_data = T)

# Use grid.arrange to arrange two plots side-by-side
grid.arrange(
  
ggplot(melt_assay) + geom_boxplot(aes(x = clusters.x, y = clr)) + labs(x = "Taxa clusters"),
ggplot(melt_assay) + geom_boxplot(aes(x = clusters.y, y = clr)) + labs(x = "Sample clusters"),

nrow = 1)
```

## Taxa vs biomarker

Here, we analyze cross-correlation between taxa and biomarkers. This is a case, where
we use _biclust_ method which is suitable for numeric matrices in general.


Load data

```{r biclust_1}
if(!require(microbiomeDataSets)){
    BiocManager::install("microbiomeDataSets")
    library(microbiomeDataSets)
}

mae <- HintikkaXOData()

mae
```

We analyze correlation between taxa and biomarkers. First, rarest taxa are filtered out.
Then cross-correlation matrix is calculated. 

```{r biclust_2}
# Subser data
mae[[1]] <- subsetByPrevalentTaxa(mae[[1]], rank = "Genus", prevalence = 0.2, detection = 0.001)
# clr-transforma
mae[[1]] <- transformSamples(mae[[1]], method = "clr", pseudocount = 1)

############################ REMOVE THIS WHEN BUG IN GETEXPERIMENTCROSSCORR IS FIXED
rownames(mae[[1]]) <- make.unique(rownames(mae[[1]]))

# Calculate correlations
corr <- getExperimentCrossCorrelation(mae, 1, 3, abund_values1 = "clr", abund_values2 = "signals", mode = "matrix", 
                                      cor_threshold = 0.2)
head(corr)
```

_biclust_ takes correlation matrix as an input and returns _biclust object. 

```{r biclust_3}
# Load package
if(!require(biclust)){
    install.packages("biclust")
    library(biclust)
}

# Find biclusters
bc <- biclust(corr, method=BCPlaid(), fit.model = y ~ m,
              background = TRUE, shuffle = 100, back.fit = 0, max.layers = 10,
              iter.startup = 10, iter.layer = 100, verbose = FALSE)

bc
```

The object includes cluster information. However compared to _cobiclust_, 
_biclust_ object includes only information about found clusters, not general cluster.

Meaning that if one cluster size of 5 features was found out of 20 features, 
those 15 features do not include to any cluster. That is why we have to create an
additional cluster for features/samples that are not assigned into any cluster.

```{r biclust_4}
# Get cluster info for features and convert it into data frame
bicluster_rows <- bc@RowxNumber
bicluster_rows <- data.frame(bicluster_rows)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those features that are not included in clusters that were found.
if( nrow(bicluster_rows) != nrow(corr) ){
    bicluster_rows <- data.frame(cluster = rep(TRUE, nrow(corr)))
} else {
  # Create additional cluster that includes those features that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_rows) > 0, FALSE, TRUE)
  # If additional cluster contains features, then add it
  if ( any(vec) ){
    bicluster_rows <- cbind(bicluster_rows, vec)
  }
}

# Give row and column names
rownames(bicluster_rows) <- rownames(corr)
colnames(bicluster_rows) <- paste0("cluster_", 1:ncol(bicluster_rows))

head(bicluster_rows)
```

```{r biclust_5}
# Get cluster information for columns
bicluster_columns <- t(bc@NumberxCol)
bicluster_columns <- data.frame(bicluster_columns)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those samples that are not included in clusters that were found.
if( nrow(bicluster_columns) != ncol(corr) ){
    bicluster_columns <- data.frame(cluster = rep(TRUE, ncol(corr)))
} else {
  # Create additional cluster that includes those samples that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_columns) > 0, FALSE, TRUE)
  # If additional cluster contains samples, then add it
  if ( any(vec) ){
    bicluster_columns <- cbind(bicluster_columns, vec)
  }

}

# Give row and column names
rownames(bicluster_columns) <- colnames(corr)
colnames(bicluster_columns) <- paste0("cluster_", 1:ncol(bicluster_columns))

head(bicluster_columns)
```

JATKA TÄSTÄ
```{r}
.get_mean_and_var <- function(tse, abund_values = "counts", clusters){
    df <- data.frame(lapply(clusters, function(x){
        tse_subset <- tse[x, ]
        assay <- assay(tse_subset, abund_values)
        mean <- mean(rowMeans2(assay, na.rm = T))
        var <- mean(rowVars(assay, na.rm = T))
        return(c(mean, var))
    }))
    rownames(df) <- c("mean", "variance")
    
    return(t(df))
}


.get_mean_and_var(mae[[1]], "clr", bicluster_features)
.get_mean_and_var(mae[[3]], "signals", bicluster_samples)
```


_pheatmap_ do not allow boolean values, so they must be converted into factors.

```{r biclust_6}
# bicluster_columns <- data.frame(apply(bicluster_columns, 2, as.factor))
# bicluster_rows <- data.frame(apply(bicluster_rows, 2, as.factor))
```


Again, we can plot clusters with heatmap.

```{r biclust_7, fig.width=10, fig.height=8}
# Adjust colors for all clusters
if( ncol(bicluster_rows) > ncol(bicluster_columns) ){
  cluster_names <- colnames(bicluster_rows)
} else {
  cluster_names <- colnames(bicluster_columns)
}
annotation_colors <- list()
for(name in cluster_names){
  annotation_colors[[name]] <- c("TRUE" = "red", "FALSE" = "white")
}

# Create a heatmap
pheatmap(corr, cluster_cols = F, cluster_rows = F,
         annotation_col = bicluster_columns, 
         annotation_row = bicluster_rows,
         annotation_colors = annotation_colors)
```

# Taxa vs taxa

Third and final example deals with situation where we want to analyze correlation
between taxa. _biclust_ is suitable for this. 

```{r biclust_8}
# Calculate cross-correlation
corr <- getExperimentCrossCorrelation(mae, 1, 1, 
                                      abund_values1 = "clr", abund_values2 = "clr", 
                                      mode = "matrix",
                                      cor_threshold = 0.2)

# Find biclusters
bc <- biclust(corr, method=BCPlaid(), fit.model = y ~ m,
              background = TRUE, shuffle = 100, back.fit = 0, max.layers = 10,
              iter.startup = 10, iter.layer = 100, verbose = FALSE)
bc
```

```{r biclust_9}
# Get cluster info for features and convert it into data frame
bicluster_rows <- bc@RowxNumber
bicluster_rows <- data.frame(bicluster_rows)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those features that are not included in clusters that were found.
if( nrow(bicluster_rows) != nrow(corr) ){
    bicluster_rows <- data.frame(cluster = rep(TRUE, nrow(corr)))
} else {
  # Create additional cluster that includes those features that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_rows) > 0, FALSE, TRUE)
  # If additional cluster contains features, then add it
  if ( any(vec) ){
    bicluster_rows <- cbind(bicluster_rows, vec)
  }
}

# Give row and column names
rownames(bicluster_rows) <- rownames(corr)
colnames(bicluster_rows) <- paste0("cluster_", 1:ncol(bicluster_rows))

head(bicluster_rows)
```


```{r biclust_10}
# Get cluster information for samples
bicluster_columns <- t(bc@NumberxCol)
bicluster_columns <- data.frame(bicluster_columns)

# If no clusters were found, create one. Otherwise create additional cluster which
# contain those samples that are not included in clusters that were found.
if( nrow(bicluster_columns) != ncol(corr) ){
    bicluster_columns <- data.frame(cluster = rep(TRUE, ncol(corr)))
} else {
  # Create additional cluster that includes those samples that
  # are not included in other clusters.
  vec <- ifelse(rowSums(bicluster_columns) > 0, FALSE, TRUE)
  # If additional cluster contains samples, then add it
  if ( any(vec) ){
    bicluster_columns <- cbind(bicluster_columns, vec)
  }

}

# Give row and column names
rownames(bicluster_columns) <- colnames(corr)
colnames(bicluster_columns) <- paste0("cluster_", 1:ncol(bicluster_columns))

head(bicluster_columns)
```

```{r biclust_11, fig.width=14, fig.height=12}
# Convert boolean values into factor
bicluster_columns <- data.frame(apply(bicluster_columns, 2, as.factor))
bicluster_rows <- data.frame(apply(bicluster_rows, 2, as.factor))

# Adjust colors for all clusters
if( ncol(bicluster_rows) > ncol(bicluster_columns) ){
  cluster_names <- colnames(bicluster_rows)
} else {
  cluster_names <- colnames(bicluster_columns)
}
annotation_colors <- list()
for(name in cluster_names){
  annotation_colors[[name]] <- c("TRUE" = "red", "FALSE" = "white")
}

pheatmap(corr, cluster_cols = F, cluster_rows = F,
         annotation_col = bicluster_columns, 
         annotation_row = bicluster_rows,
         annotation_colors = annotation_colors)
```

## Session Info {-}

```{r sessionInfo, echo=FALSE, results='asis'}
prettySessionInfo()
```
